---
title: "Graph) Minimum Spanning Tree"
tags: ds mst graph tree
---

_ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬_ ğŸŒ³

<!--more-->

## MST

-   ëª¨ë“  ì •ì ì„ ì—°ê²°í•˜ëŠ” ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œì¸ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” íŠ¸ë¦¬
-   Greedyí•˜ê²Œ ê°€ê¸° ë•Œë¬¸ì— ìœ ì¼í•´ëŠ” ì•„ë‹ìˆ˜ë„ ìˆë‹¤.

## êµ¬í˜„

MSTë¥¼ êµ¬í˜„í•˜ê¸° ìœ„í•œ ë°©ë²•ìœ¼ë¡œëŠ” `Kruskal`, `Prim` ì•Œê³ ë¦¬ì¦˜ì´ ìˆë‹¤.

1. Kruskal Algorithm

    - ì‹œê°„ë³µì¡ë„ : ì •ë ¬ `O(ElogE)` + ê°„ì„ ë§ˆë‹¤ Union-Find `O(E * 1)`

    - ê°„ì„  ë¦¬ìŠ¤íŠ¸ ìë£Œêµ¬ì¡°, ê°€ì¤‘ì¹˜ ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ (Greedy)
        ```c++
            //edge -> start, end, cost
            vector<edge> v;
            // TODO: ì—°ì‚°ì ì˜¤ë²„ë¡œë”©
            sort(v.begin(), v.end());
        ```
    - Union-Findë¥¼ ì´ìš©í•´ì„œ Cycle ì²´í¬, Cycleì´ ì—†ë‹¤ë©´ ì—°ê²°
        ```c++
            for(int i=0;i<v.size();i++){
                int x = find(v[i].start);
                int y = find(v[i].end);
                if(x != y){ // ê°™ì€ ì§‘í•©ì´ ì•„ë‹ˆë¼ë©´ Cycle ì—†ìŒ
                    union(x,y); // ì—°ê²°
                    ans += v[i].cost; // ìµœì†Œ ê°€ì¤‘ì¹˜ ê°„ì„ ì˜ í•©
                }
            }
        ```

2. Prim

    - ì‹œê°„ë³µì¡ë„ : ìµœì†Œ ê°’ ìš°ì„ ìˆœìœ„ í ì´ìš©í•˜ë©´ `O(ElogE)`

    - ì•„ë¬´ ì •ì ì´ë‚˜ ì„ íƒ -> ì—°ê²° ê°„ì„  ì¤‘ì— ìµœì†Œê°’ì„ mstì— ì¶”ê°€ -> ëª¨ë“  ì •ì ì´ ì„ íƒë  ë•Œ ê¹Œì§€
        ```c++
            while (!q.empty()) {
                auto p = q.top();
                q.pop();
                if (check[p.second]) continue;
                check[p.second] = true;
                ans += -p.first;
                int x = p.second;
                for (auto &p : a[x]) {
                    // c++ì€ max heapì´ë¼ ìŒìˆ˜ ê°’ì„ ë„£ì–´ì„œ min heapì²˜ëŸ¼ ì‚¬ìš©
                    q.push(make_pair(-p.second, p.first));
                }
            }
        ```
